# Big O Complexity

Big O (O()) describes the upper bound (or worst case) of complexity.
Theta (Θ()) describes the tight or exact bound (or overlap between upper and lower bounds) of complexity.
Omega (Ω()) describes the lower bound of complexity.
Little O (o()) describes the upper bound excluding the exact bound (i.e. any overlap with the exact or tight bound).
### Contents
- Fastest
- [O(1)](#O(1))
- [O(log n)](#O(logn))
- [O(n)](#O(n))
- [O(n log n)](#O(nlogn))
- [O(n^2)](#O(n^2))
- [O(2^n)](#O(2^n))
- [O(n!)](#O(n!))
- Slowest

## O(1)
### Constant
Big O of 1 or 'constant time' does not increase with the size of the data set. 
#### Time
No matter how big a set, the time to run should be roughly the same.
#### Space
The function will add a fixed amount to the memory requirements when running.
#### Example - Access
```
function getElementAtIndex(array, index) {
    return array[index];
}

const myArray = [10, 20, 30, 40, 50];
const element = getElementAtIndex(myArray, 2);

```
## O(log n)
### Logarithmic / Sub-Linear

Divide and conquer algorithms that split the work in two recursively will have this complexity.

#### Time
As the size of a set increases the time requirements increase logarithmically (sub-linearly) meaning the performance relative to a linear algorithm improves as the data set grows.
#### Space
Will need logarithmically increasing space as the data set grows.
#### Example - Binary Search
```
function binarySearch(array, target) {
    let left = 0;
    let right = array.length - 1;

    while (left <= right) {
        const mid = Math.floor((left + right) / 2);

        if (array[mid] === target) {
            return mid;
        } else if (array[mid] < target) {
            left = mid + 1;
        } else {
            right = mid - 1;
        }
    }

    return -1;
}

```
## O(n)
### Linear
#### Time


#### Space

#### Example - Linear Search
```


```
## O(n log n)
### Super Linear
#### Time


#### Space

#### Example - Merge Sort
```


```
## O(n^2)
### Quadratic
#### Time


#### Space

#### Example - Bubble Sort
```


```
## O(2^n)
### Exponential

#### Time


#### Space

#### Example - Recursive Fibonacci Algorithm
```
function fibonacciRecursive(n) {
  if (n <= 1) {
    return n;
  }
  return fibonacciRecursive(n - 1) + fibonacciRecursive(n - 2);
}

```
## O(n!)
### Factorial
#### Time


#### Space

#### Example - Heap Permutations
```
function generatePermutations(n) {
  // Helper function to generate permutations recursively
  function permuteHelper(currentPerm, remainingItems) {
    // Base case: If no remaining items, add the current permutation to the result
    if (remainingItems.length === 0) {
      permutations.push(currentPerm.slice()); // Add a copy of the current permutation
      return;
    }

    // Recursive case: Generate permutations by trying each remaining item as the next element
    for (let i = 0; i < remainingItems.length; i++) {
      const item = remainingItems[i]; // Take the current item to add to the permutation
      const newPerm = currentPerm.concat(item); // Create a new permutation with the item added
      const newRemaining = remainingItems.slice(0, i).concat(remainingItems.slice(i + 1));
      // Recursively call with the new permutation and the remaining items
      permuteHelper(newPerm, newRemaining);
    }
  }

  // Create an array of numbers from 1 to n
  const inputArray = Array.from({ length: n }, (_, i) => i + 1);
  const permutations = []; // Array to store the generated permutations
  permuteHelper([], inputArray); // Start the permutation generation with an empty current permutation
  return permutations; // Return the array of permutations
}

const n = 3; // Set the value of n
const result = generatePermutations(n); // Generate permutations for n
console.log(result); // Output the result


```