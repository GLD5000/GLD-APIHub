# JavaScript Sorting Algorithms

### Contents
- [Bubble Sort](#BubbleSort)
- [Insertion Sort](#InsertionSort)
- [Selection Sort](#SelectionSort)
- [Quick Sort](#QuickSort)
- [Bucket Sort](#BucketSort)
- [Radix Sort](#RadixSort)
- [Counting Sort](#CountingSort)
- [Merge Sort](#MergeSort)
- [Heap Sort](#HeapSort)

### Bubble Sort
Simple, but inefficient. Repeatedly swap adjacent elements.
- Average Time Complexity O(n^2)	
- Big O Time Complexity O(n^2)	
- Big O Space Complexity O(1)	
```
```
### Insertion Sort
Builds the final sorted array one element at a time.
- Average Time Complexity O(n^2)	
- Big O Time Complexity O(n^2)	
- Big O Space Complexity O(1)	
```
```
### Selection Sort
Repeatedly selects the minimum element and swaps with current position.
- Average Time Complexity O(n^2)	
- Big O Time Complexity O(n^2)	
- Big O Space Complexity O(1)	
```
```
### Quick Sort
Divide and conquer approach. Fastest in practice for random data.
- Average Time Complexity O(n log n)	
- Big O Time Complexity O(n^2)	
- Big O Space Complexity O(log n)	
```
```
### Bucket Sort
Distributes elements into buckets and sorts each bucket.
- Average Time Complexity O(n + k)	
- Big O Time Complexity O(n^2)	
- Big O Space Complexity O(n)	
```
```
### Radix Sort
Sorts by digits. Efficient for sorting integers.
- Average Time Complexity O(kn)		
- Big O Time Complexity O(kn)
- Big O Space Complexity O(n + k)	
```
```
### Counting Sort
Sorts by counting occurrences of each element.
- Average Time Complexity O(n + k)	
- Big O Time Complexity O(n + k)	
- Big O Space Complexity O(n + k)	
```
```
### Merge Sort
Divide and conquer approach. Efficient for large datasets.
- Average Time Complexity O(n log n)	
- Big O Time Complexity O(n log n)	
- Big O Space Complexity O(n)	
```
```
### Heap Sort
Builds a binary heap and repeatedly extracts the maximum.
- Average Time Complexity O(n log n)	
- Big O Time Complexity O(n log n)	
```
```- Big O Space Complexity O
(1)	